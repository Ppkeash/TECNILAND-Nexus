/**
 * NeoForgeLoaderInstaller
 * 
 * Handles installation and validation of NeoForge Loader.
 * 
 * NeoForge is a modern fork of MinecraftForge for MC 1.20.2+
 * - Similar installation process to Forge (installer jar → install_profile.json → processors)
 * - Maven: https://maven.neoforged.net/releases/
 * - Supported MC versions: 1.20.2+
 * 
 * Installation flow:
 * 1. Validate MC version compatibility (≥ 1.20.2)
 * 2. Download installer JAR from NeoForge Maven
 * 3. Parse install_profile.json from installer
 * 4. Extract version.json
 * 5. Download all libraries
 * 6. Execute processors (if any)
 * 7. Validate installation
 */

const BaseLoaderInstaller = require('./BaseLoaderInstaller')
const fs = require('fs-extra')
const path = require('path')
const got = require('got')
const AdmZip = require('adm-zip')
const { getLogger } = require('../../loggerutil')
const { ForgeProcessorRunner } = require('../../forgeprocessor')

const logger = getLogger('NeoForgeLoaderInstaller')

// NeoForge Maven repository
const NEOFORGE_MAVEN_BASE = 'https://maven.neoforged.net/releases'

class NeoForgeLoaderInstaller extends BaseLoaderInstaller {
    
    constructor(config) {
        super(config)
        this.loaderType = 'neoforge'
    }
    
    // ============================================
    // ABSTRACT METHOD IMPLEMENTATIONS
    // ============================================
    
    getLoaderType() {
        return 'neoforge'
    }
    
    /**
     * NeoForge supports Minecraft 1.20.2+
     */
    getSupportedMinecraftVersions() {
        return {
            min: '1.20.2',
            max: '1.99.99' // No upper limit known yet
        }
    }
    
    /**
     * Override: NeoForge validation is static (1.20.2+)
     */
    async validateCompatibility() {
        if (!this.isMinecraftVersionSupported()) {
            throw new Error(
                `NeoForge no es compatible con Minecraft ${this.minecraftVersion}. ` +
                'Requiere Minecraft 1.20.2 o superior.'
            )
        }
        
        logger.info(`✓ NeoForge es compatible con MC ${this.minecraftVersion}`)
    }
    
    async validateInstallation() {
        try {
            const versionJsonPath = this.getVersionJsonPath()
            
            if (!await fs.pathExists(versionJsonPath)) {
                logger.debug(`NeoForge version.json not found at ${versionJsonPath}`)
                return false
            }
            
            // Read and validate version.json structure
            const versionJson = await fs.readJson(versionJsonPath)
            
            if (!versionJson.id || !versionJson.mainClass || !versionJson.libraries) {
                logger.warn('NeoForge version.json is malformed')
                return false
            }
            
            // ✅ CRITICAL: Invalidar instalaciones viejas sin _neoForgeMeta
            if (!versionJson._neoForgeMeta || !versionJson._neoForgeMeta.version) {
                logger.warn('⚠️ NeoForge installation is OLD (no _neoForgeMeta). Marking as invalid to force regeneration.')
                return false
            }
            
            logger.debug(`NeoForge installation validated: version=${versionJson._neoForgeMeta.version}`)
            
            // Check if all libraries exist
            for (const lib of versionJson.libraries) {
                const libPath = this.getLibraryPath(lib.name)
                if (!await fs.pathExists(libPath)) {
                    logger.debug(`NeoForge library missing: ${lib.name}`)
                    return false
                }
            }
            
            // ✅ CRITICAL: Verify processor-generated artifacts (robust validation)
            // These files are generated by processors and are REQUIRED for NeoForge to launch
            // Use glob patterns to avoid hardcoding neoFormVersion which may be undefined
            
            // 1. Check for MC client srg jar (pattern: client-1.20.4-*-srg.jar)
            const clientDir = path.join(this.commonDir, 'libraries', 'net', 'minecraft', 'client')
            const clientDirs = await fs.readdir(clientDir).catch(() => [])
            
            let hasSrgJar = false
            let hasExtraJar = false
            
            for (const dir of clientDirs) {
                if (dir.startsWith(this.minecraftVersion)) {
                    const dirPath = path.join(clientDir, dir)
                    const files = await fs.readdir(dirPath).catch(() => [])
                    
                    if (files.some(f => f.endsWith('-srg.jar'))) {
                        hasSrgJar = true
                        logger.debug(`Found SRG jar: ${dir}/*-srg.jar`)
                    }
                    if (files.some(f => f.endsWith('-extra.jar'))) {
                        hasExtraJar = true
                        logger.debug(`Found EXTRA jar: ${dir}/*-extra.jar`)
                    }
                }
            }
            
            if (!hasSrgJar) {
                logger.warn(`⚠️ Processor artifact missing: client-${this.minecraftVersion}-*-srg.jar`)
                logger.warn('   This means processors were not executed. Marking installation as invalid.')
                return false
            }
            
            if (!hasExtraJar) {
                logger.warn(`⚠️ Processor artifact missing: client-${this.minecraftVersion}-*-extra.jar`)
                logger.warn('   This means processors were not executed. Marking installation as invalid.')
                return false
            }
            
            // 2. Check for NeoForge client jar
            const neoforgeClientJar = path.join(
                this.commonDir, 'libraries', 'net', 'neoforged', 'neoforge', 
                this.loaderVersion, `neoforge-${this.loaderVersion}-client.jar`
            )
            
            if (!await fs.pathExists(neoforgeClientJar)) {
                logger.warn(`⚠️ Processor artifact missing: neoforge-${this.loaderVersion}-client.jar`)
                logger.warn('   This means processors were not executed. Marking installation as invalid.')
                return false
            }
            
            logger.debug('NeoForge installation is valid (all libraries + processor artifacts present)')
            return true
            
        } catch (error) {
            logger.error(`Error validating NeoForge installation: ${error.message}`)
            return false
        }
    }
    
    async install() {
        try {
            this.reportProgress(`Instalando NeoForge ${this.loaderVersion} para Minecraft ${this.minecraftVersion}...`)
            
            // 1. Strict validation
            await this.validateCompatibility()
            
            // 2. Download installer JAR
            this.reportProgress('Descargando instalador de NeoForge...')
            const installerPath = await this.downloadInstaller()
            
            // 3. Parse install_profile.json
            this.reportProgress('Analizando perfil de instalación...')
            const installProfile = await this.parseInstallProfile(installerPath)
            logger.info('✅ NeoForge installer parsed install_profile.json')
            
            // 4. Extract version.json
            this.reportProgress('Extrayendo version.json...')
            const versionJson = await this.extractVersionJson(installerPath, installProfile)
            logger.info(`✅ Extracted version.json to ${this.getVersionJsonPath()}`)
            
            // 5. Download libraries
            this.reportProgress('Descargando librerías de NeoForge...')
            await this.downloadLibraries(versionJson.libraries)
            
            // 6. Download install_profile artifacts (datamap + processor inputs)
            if (installProfile.processors && installProfile.processors.length > 0) {
                this.reportProgress('Descargando artefactos del perfil de instalación...')
                await this.downloadInstallProfileArtifacts(installProfile, 'client')
            }
            
            // 7. Execute processors (if any)
            if (installProfile.processors && installProfile.processors.length > 0) {
                this.reportProgress('Ejecutando processors de NeoForge...')
                await this.executeProcessors(installProfile, installerPath, versionJson)
            }
            
            // 8. Ensure universal JAR exists (compatibility shim for ModLauncher)
            await this.ensureNeoForgeUniversalJar()
            
            // 9. Validate installation
            const isValid = await this.validateInstallation()
            if (!isValid) {
                throw new Error('NeoForge installation validation failed after install')
            }
            
            this.reportProgress('NeoForge instalado correctamente')
            logger.info(`NeoForge ${this.loaderVersion} installed successfully for MC ${this.minecraftVersion}`)
            
            return { success: true }
            
        } catch (error) {
            logger.error(`NeoForge installation failed: ${error.message}`)
            throw error
        }
    }
    
    async getVersionJson() {
        const versionJsonPath = this.getVersionJsonPath()
        
        if (await fs.pathExists(versionJsonPath)) {
            // ✅ CRITICAL: Ensure universal JAR shim exists before every launch
            // This handles cases where installation was done before shim logic was added
            await this.ensureNeoForgeUniversalJar()
            
            return await fs.readJson(versionJsonPath)
        }
        
        return null
    }
    
    // ============================================
    // NEOFORGE-SPECIFIC METHODS
    // ============================================
    
    /**
     * Download NeoForge installer JAR
     * @returns {Promise<string>} Path to downloaded installer
     */
    async downloadInstaller() {
        const installerJar = `neoforge-${this.loaderVersion}-installer.jar`
        const installerPath = path.join(this.commonDir, 'temp', installerJar)
        
        // Create temp directory
        await fs.ensureDir(path.dirname(installerPath))
        
        // Check if already downloaded
        if (await fs.pathExists(installerPath)) {
            logger.info(`Installer already downloaded: ${installerPath}`)
            return installerPath
        }
        
        // Build download URL: https://maven.neoforged.net/releases/net/neoforged/neoforge/{version}/neoforge-{version}-installer.jar
        const url = `${NEOFORGE_MAVEN_BASE}/net/neoforged/neoforge/${this.loaderVersion}/${installerJar}`
        logger.info(`Downloading NeoForge installer from: ${url}`)
        
        try {
            const response = await got.get(url, { responseType: 'buffer', timeout: { request: 60000 } })
            await fs.writeFile(installerPath, response.body)
            logger.info(`✅ Downloaded NeoForge installer: ${installerPath}`)
            return installerPath
        } catch (error) {
            throw new Error(`Failed to download NeoForge installer: ${error.message}. URL: ${url}`)
        }
    }
    
    /**
     * Parse install_profile.json from installer JAR
     * @param {string} installerPath Path to installer JAR
     * @returns {Promise<Object>} Parsed install profile
     */
    async parseInstallProfile(installerPath) {
        try {
            const zip = new AdmZip(installerPath)
            const profileEntry = zip.getEntry('install_profile.json')
            
            if (!profileEntry) {
                throw new Error('install_profile.json not found in installer JAR')
            }
            
            const profileContent = profileEntry.getData().toString('utf-8')
            const profile = JSON.parse(profileContent)
            
            logger.info('✅ Parsed install_profile.json')
            logger.debug(`Profile version: ${profile.version}, Minecraft: ${profile.minecraft}`)
            
            return profile
            
        } catch (error) {
            throw new Error(`Failed to parse install_profile.json: ${error.message}`)
        }
    }
    
    /**
     * Extract version.json from installer and save it
     * @param {string} installerPath Path to installer JAR
     * @param {Object} installProfile Parsed install profile
     * @returns {Promise<Object>} Extracted and saved version.json
     */
    async extractVersionJson(installerPath, installProfile) {
        try {
            const zip = new AdmZip(installerPath)
            
            // Get path from install_profile.json (field: "json")
            let profileJsonPath = installProfile.json || installProfile.jsonPath || 'version.json'
            logger.info(`install_profile.json says profile json path: "${profileJsonPath}"`)
            
            // Normalize path (remove ./ or / prefix, convert backslashes)
            profileJsonPath = profileJsonPath.replace(/\\/g, '/') // Convert backslashes
            profileJsonPath = profileJsonPath.replace(/^\.\//, '') // Remove ./
            profileJsonPath = profileJsonPath.replace(/^\//, '')   // Remove leading /
            
            logger.info(`Normalized profile json path: "${profileJsonPath}"`)
            
            // Try to extract using the specified path
            let versionEntry = zip.getEntry(profileJsonPath)
            
            // FALLBACK: If not found, search intelligently
            if (!versionEntry) {
                logger.warn(`Profile json not found at "${profileJsonPath}", searching for candidates...`)
                
                const allEntries = zip.getEntries()
                const candidates = []
                
                // Look for .json files that match NeoForge patterns
                for (const entry of allEntries) {
                    const entryName = entry.entryName
                    if (!entryName.endsWith('.json')) continue
                    
                    // Priority 1: Contains /versions/ or neoforge- in path
                    if (entryName.includes('/versions/') || entryName.includes('neoforge-')) {
                        candidates.push({ entry, priority: 1, reason: 'contains /versions/ or neoforge-' })
                    }
                    // Priority 2: Named version.json
                    else if (entryName.endsWith('version.json')) {
                        candidates.push({ entry, priority: 2, reason: 'named version.json' })
                    }
                    // Priority 3: Any .json at root level
                    else if (!entryName.includes('/')) {
                        candidates.push({ entry, priority: 3, reason: 'root-level .json' })
                    }
                }
                
                if (candidates.length === 0) {
                    const jsonEntries = allEntries.filter(e => e.entryName.endsWith('.json')).map(e => e.entryName)
                    throw new Error(
                        'No version.json found in installer JAR.\n' +
                        `  Tried: "${profileJsonPath}"\n` +
                        `  Available .json files: ${jsonEntries.join(', ') || 'none'}`
                    )
                }
                
                // Sort by priority and pick best candidate
                candidates.sort((a, b) => a.priority - b.priority)
                
                // If multiple same-priority candidates, prefer one matching installProfile.version
                const bestPriority = candidates[0].priority
                const bestCandidates = candidates.filter(c => c.priority === bestPriority)
                
                let chosen = bestCandidates[0]
                if (bestCandidates.length > 1 && installProfile.version) {
                    const matchingVersion = bestCandidates.find(c => 
                        c.entry.entryName.includes(installProfile.version)
                    )
                    if (matchingVersion) {
                        chosen = matchingVersion
                    }
                }
                
                versionEntry = chosen.entry
                logger.info(`Found candidate: "${versionEntry.entryName}" (${chosen.reason})`)
                
                if (bestCandidates.length > 1) {
                    logger.warn(`Multiple candidates found, chose: "${versionEntry.entryName}"`)
                    logger.warn(`  Other candidates: ${bestCandidates.filter(c => c !== chosen).map(c => c.entry.entryName).join(', ')}`)
                }
            }
            
            logger.info(`Extracting profile json from jar entry: "${versionEntry.entryName}"`)
            
            const versionContent = versionEntry.getData().toString('utf-8')
            const versionJson = JSON.parse(versionContent)
            
            // Extract neoFormVersion from install_profile data (e.g., "20231207.154220")
            let neoFormVersion = null
            if (installProfile.data && installProfile.data.NEOFORGE) {
                const neoforgeValue = installProfile.data.NEOFORGE.client || installProfile.data.NEOFORGE
                // Format: [net.neoforged:neoforge:VERSION] - extract VERSION
                const match = neoforgeValue.match(/\[net\.neoforged:neoforge:([^\]]+)\]/)
                if (match) {
                    neoFormVersion = match[1]
                }
            }
            
            // Fallback: extract from MCP_VERSION or data variables
            if (!neoFormVersion && installProfile.data) {
                for (const [key, value] of Object.entries(installProfile.data)) {
                    const val = value.client || value
                    if (typeof val === 'string' && val.includes('-')) {
                        // Look for pattern like "1.20.4-20231207.154220"
                        const parts = val.split('-')
                        if (parts.length > 1 && parts[1].match(/^\d{8}\.\d{6}$/)) {
                            neoFormVersion = parts[1]
                            logger.debug(`Extracted neoFormVersion from ${key}: ${neoFormVersion}`)
                            break
                        }
                    }
                }
            }
            
            // Add metadata for validation
            versionJson._neoForgeMeta = {
                version: this.loaderVersion,
                minecraftVersion: this.minecraftVersion,
                neoFormVersion: neoFormVersion,
                installedAt: new Date().toISOString()
            }
            
            // Save to versions directory
            const targetPath = this.getVersionJsonPath()
            await fs.ensureDir(path.dirname(targetPath))
            await fs.writeJson(targetPath, versionJson, { spaces: 2 })
            
            logger.info(`✅ Saved version.json to ${targetPath}`)
            
            return versionJson
            
        } catch (error) {
            throw new Error(`Failed to extract version.json: ${error.message}`)
        }
    }
    
    /**
     * Download artifacts referenced in install_profile.json (datamap + processor args)
     * NeoForge uses Maven coordinates in [...] that may include @zip or other extensions
     * @param {Object} installProfile The install_profile.json
     * @param {string} side Either 'client' or 'server' (default: 'client')
     * @returns {Promise<void>}
     */
    async downloadInstallProfileArtifacts(installProfile, side = 'client') {
        try {
            const artifacts = new Set()
            
            // 1. Extract Maven coordinates from datamap
            if (installProfile.data) {
                for (const [, value] of Object.entries(installProfile.data)) {
                    let dataValue = value
                    
                    // If value is object with client/server, use the specified side
                    if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
                        dataValue = value[side]
                    }
                    
                    // Extract coordinates from [...] brackets
                    if (typeof dataValue === 'string') {
                        const match = dataValue.match(/\[([^\]]+)\]/)
                        if (match) {
                            artifacts.add(match[1])
                        }
                    }
                }
            }
            
            // 2. Extract Maven coordinates from processor args
            if (installProfile.processors) {
                for (const processor of installProfile.processors) {
                    if (processor.args) {
                        for (const arg of processor.args) {
                            if (typeof arg === 'string') {
                                const match = arg.match(/\[([^\]]+)\]/)
                                if (match) {
                                    artifacts.add(match[1])
                                }
                            }
                        }
                    }
                }
            }
            
            logger.info(`Found ${artifacts.size} install_profile artifacts from datamap/processors`)
            
            // 3. Filter and download only required artifacts
            // Most [...] entries are path resolutions or outputs (not downloadable)
            let downloaded = 0
            for (const coordinate of artifacts) {
                const shouldDownload = await this.downloadProcessorArtifact(coordinate)
                if (shouldDownload) {
                    downloaded++
                }
            }
            
            logger.info(`✅ Downloaded ${downloaded}/${artifacts.size} required install_profile artifacts`)
            
        } catch (error) {
            throw new Error(`Failed to download install_profile artifacts: ${error.message}`)
        }
    }
    
    /**
     * Download a single processor artifact (supports @zip, @jar, etc.)
     * Filters out virtual artifacts (net.minecraft outputs) and only downloads necessary inputs
     * @param {string} coordinate Maven coordinate (e.g. "net.neoforged:neoform:1.20.4-20231207.154220@zip")
     * @returns {Promise<boolean>} True if artifact was downloaded, false if skipped
     */
    async downloadProcessorArtifact(coordinate) {
        try {
            // Parse Maven coordinate using BaseLoaderInstaller's parser
            const parsed = this.parseMavenCoordinate(coordinate)
            
            // FILTER: Skip net.minecraft artifacts (they are virtual/generated outputs)
            if (parsed.group === 'net.minecraft') {
                logger.debug(`Skipping virtual net.minecraft artifact (generated/downloaded by processors): ${coordinate}`)
                return false
            }
            
            // ALLOWLIST: Only download net.neoforged:neoform@zip (required for MCP_DATA processor)
            const isNeoform = parsed.group === 'net.neoforged' && 
                             parsed.artifact === 'neoform' && 
                             parsed.ext === 'zip'
            
            if (!isNeoform) {
                logger.debug(`Skipping non-essential artifact (not neoform@zip): ${coordinate}`)
                return false
            }
            
            // Build file path
            const groupPath = parsed.group.replace(/\./g, path.sep)
            const fileName = parsed.classifier
                ? `${parsed.artifact}-${parsed.version}-${parsed.classifier}.${parsed.ext}`
                : `${parsed.artifact}-${parsed.version}.${parsed.ext}`
            
            const targetPath = path.join(
                this.commonDir,
                'libraries',
                groupPath,
                parsed.artifact,
                parsed.version,
                fileName
            )
            
            // Skip if already exists
            if (await fs.pathExists(targetPath)) {
                logger.debug(`Processor artifact already exists: ${coordinate}`)
                return true // Count as downloaded (already present)
            }
            
            // Determine repository URL
            let repoBase = 'https://repo1.maven.org/maven2/' // Default: Maven Central
            
            // NeoForge-related groups use NeoForge Maven
            if (parsed.group.startsWith('net.neoforged') || 
                parsed.group.startsWith('cpw.mods') ||
                parsed.group.startsWith('net.minecraftforge')) {
                repoBase = 'https://maven.neoforged.net/releases/'
            }
            
            // Build download URL
            const urlPath = `${parsed.group.replace(/\./g, '/')}/${parsed.artifact}/${parsed.version}/${fileName}`
            const downloadUrl = `${repoBase}${urlPath}`
            
            logger.info(`Downloading required processor input: ${coordinate} -> ${path.basename(targetPath)}`)
            
            // Download
            await fs.ensureDir(path.dirname(targetPath))
            const response = await got(downloadUrl, { responseType: 'buffer', retry: { limit: 3 } })
            await fs.writeFile(targetPath, response.body)
            
            logger.debug(`✓ Downloaded processor artifact: ${fileName}`)
            
            return true // Successfully downloaded
            
        } catch (error) {
            throw new Error(`Failed to download processor artifact ${coordinate}: ${error.message}`)
        }
    }
    
    /**
     * Ensure NeoForge universal JAR exists (compatibility shim for ModLauncher)
     * ModLauncher expects neoforge-VERSION-universal.jar but processors generate -client.jar
     * This creates a hardlink/copy as needed
     * @returns {Promise<void>}
     */
    async ensureNeoForgeUniversalJar() {
        try {
            const librariesDir = path.join(this.commonDir, 'libraries')
            const baseDir = path.join(librariesDir, 'net', 'neoforged', 'neoforge', this.loaderVersion)
            
            const clientJar = path.join(baseDir, `neoforge-${this.loaderVersion}-client.jar`)
            const universalJar = path.join(baseDir, `neoforge-${this.loaderVersion}-universal.jar`)
            
            // If universal jar already exists, nothing to do
            if (await fs.pathExists(universalJar)) {
                logger.debug('NeoForge universal jar already exists')
                return
            }
            
            // If client jar exists, create shim
            if (await fs.pathExists(clientJar)) {
                try {
                    // Try hardlink first (faster, no disk space)
                    fs.linkSync(clientJar, universalJar)
                    logger.info(`✅ NeoForge universal shim created (hardlink): neoforge-${this.loaderVersion}-universal.jar -> neoforge-${this.loaderVersion}-client.jar`)
                } catch (linkError) {
                    // Fallback to copy if hardlink fails
                    await fs.copyFile(clientJar, universalJar)
                    logger.info(`✅ NeoForge universal shim created (copy): neoforge-${this.loaderVersion}-universal.jar -> neoforge-${this.loaderVersion}-client.jar`)
                }
                return
            }
            
            // Fallback: search for any neoforge-VERSION-*.jar
            logger.warn('NeoForge client jar not found, searching for fallback...')
            
            const files = await fs.readdir(baseDir).catch(() => [])
            const neoforgeJars = files.filter(f => 
                f.startsWith(`neoforge-${this.loaderVersion}-`) && 
                f.endsWith('.jar') && 
                f !== `neoforge-${this.loaderVersion}-universal.jar`
            )
            
            if (neoforgeJars.length > 0) {
                // Prefer client.jar if somehow missed, otherwise use first available
                const sourceJar = neoforgeJars.find(f => f.includes('-client.jar')) || neoforgeJars[0]
                const sourcePath = path.join(baseDir, sourceJar)
                
                try {
                    fs.linkSync(sourcePath, universalJar)
                    logger.warn(`⚠️ NeoForge universal shim created from fallback (hardlink): ${sourceJar}`)
                } catch (linkError) {
                    await fs.copyFile(sourcePath, universalJar)
                    logger.warn(`⚠️ NeoForge universal shim created from fallback (copy): ${sourceJar}`)
                }
                return
            }
            
            // Fatal: no NeoForge JAR found
            throw new Error(
                `NeoForge runtime jar missing: expected neoforge-${this.loaderVersion}-client.jar or any ` +
                `neoforge-${this.loaderVersion}-*.jar in ${baseDir}. Processors may not have run correctly.`
            )
            
        } catch (error) {
            logger.error(`Failed to ensure NeoForge universal jar: ${error.message}`)
            throw error
        }
    }
    
    /**
     * Execute NeoForge processors (similar to Forge)
     * @param {Object} installProfile The install_profile.json
     * @param {string} installerPath Path to installer JAR
     * @param {Object} versionJson The version.json
     * @returns {Promise<void>}
     */
    async executeProcessors(installProfile, installerPath, versionJson) {
        const processors = installProfile.processors || []
        logger.info(`Executing ${processors.length} NeoForge processors...`)
        
        if (processors.length === 0) {
            logger.info('No processors to execute')
            return
        }
        
        // Get Minecraft client JAR path
        const minecraftJarName = `${this.minecraftVersion}.jar`
        const minecraftJarPath = path.join(this.versionsDir, this.minecraftVersion, minecraftJarName)
        
        if (!await fs.pathExists(minecraftJarPath)) {
            logger.warn(`Minecraft JAR not found at ${minecraftJarPath}. Processors may fail.`)
        }
        
        // Get Java executable
        // TODO: Use actual Java path from JavaGuard
        const javaExecutable = process.platform === 'win32' ? 'javaw.exe' : 'java'
        
        // Load installer zip
        const installerZip = new AdmZip(installerPath)
        
        // Create processor runner (reuse Forge implementation)
        const runner = new ForgeProcessorRunner(
            installProfile,
            installerZip,
            versionJson,
            {
                commonDir: this.commonDir,
                minecraftJar: minecraftJarPath,
                javaExecutable: javaExecutable,
                installerPath: installerPath
            },
            this.progressCallback
        )
        
        // Execute all processors
        const result = await runner.runAll()
        
        if (result.success) {
            logger.info(`✅ All NeoForge processors executed successfully (${result.executed}/${result.total})`)
        } else {
            throw new Error('Processor execution failed')
        }
    }
    
    /**
     * Get the version ID for this NeoForge installation
     * @returns {string} Version ID (e.g., "neoforge-20.4.196")
     */
    getVersionId() {
        return `neoforge-${this.loaderVersion}`
    }
    
    /**
     * Get path to version.json file
     * @returns {string} Full path to version.json
     */
    getVersionJsonPath() {
        const versionId = this.getVersionId()
        return path.join(this.versionsDir, versionId, `${versionId}.json`)
    }
    
    /**
     * Get path to a library file from Maven coordinates
     * @param {string} mavenCoords Maven coordinates (group:artifact:version[@ext][:classifier])
     * @returns {string} Full path to library JAR
     */
    getLibraryPath(mavenCoords) {
        // Use the parser from BaseLoaderInstaller to handle @ext correctly
        const parsed = this.parseMavenCoordinate(mavenCoords)
        const { group, artifact, version, ext, classifier } = parsed
        
        const groupPath = group.replace(/\./g, '/')
        const classifierSuffix = classifier ? `-${classifier}` : ''
        const jarName = `${artifact}-${version}${classifierSuffix}.${ext}`
        
        return path.join(this.librariesDir, groupPath, artifact, version, jarName)
    }
}

module.exports = NeoForgeLoaderInstaller
